# 数据结构与算法

## 1.稀疏数组

因为数组默认值为0，因此记录了很多没意义的数据。

### 1.1基本介绍

当一个数组中大部分元素为0，或者为同一个数值的数组时，可以使用稀疏数组来保存该数据。

### 1.2稀疏数组的处理方法

- 记录数组一共有几行几列，有多少个不同的值。
- 把具有不同值的元素的行列及值记录在一个小规模的数组中（稀疏数组），从而缩小程序的规模。

![image text](https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/1.png)

### 1.3应用实例

![image text](https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/2.png)

```c++
二维数组转稀疏数组的思路：
    1.遍历原始的二维数组，得到有效数据的个数sum。
    2.根据sum就可以创建稀疏数组 int sparseArr[sum+1][3]。
    3.将二维数组的有效数据存入到稀疏数组。

稀疏数组转二维数组的思路：
    1.先读取稀疏数组第一行，根据第一行数据，创建二维数组，
      int chessArr[sparseArr[0][0]][sparseArr[0][1]]。
    2.再读取稀疏数组后几行的数据，并赋给二维数组即可。
```

### 1.4代码实现

```c++
int main()
{
    //创建一个原始的二维数组11*11
    //0：没有棋子，1：黑子，2：蓝子
    int chessArr1[11 ][11]={};
    chessArr1[1][2]=1;
    chessArr2[2][4]=2;
    
    //将二维数组中转换为稀疏数组
    //1.先遍历二维数组，得出非0数据的个数
    int sum=0;
    for(int i=0;i<11;i++)
    {
        for(int j=0;j<11;j++)
        {
            if(chessArr1[i][j]!=0)
            {
                sum++;
            }
        }
    }
    //2.创建对应稀疏数组
    int sparseArr[sum+1][3]={};
    //2.1给稀疏数组赋值
    sparseArr[0][0]=11;
    sparseArr[0][1]=11;
    sparseArr[0][2]=sum;
    //2.2遍历二维数组，将非0的值存到稀疏数组
    int count=0;//count用来记录是第几个非0值
      for(int i=0;i<11;i++)
    {
        for(int j=0;j<11;j++)
        {
            if(chessArr1[i][j]!=0)
            {
                count++;
                sparse[count][0]=i;
                sparse[count][1]=j;
                sparse[count][2]=chessArr1[i][j];
            }
        }
    }
    
    //将稀疏数组恢复二维数组
    //1.先读取稀疏数组第一行，根据第一行数据，创建二维数组
    int chessArr2[sparseArr[0][0]][sparseArr[0][1]]={};
    // 2.再读取稀疏数组后几行的数据，并赋给二维数组即可
    for(int i=1;i<sum+1;i++)
    {
        chessArr2[sparseArr[i][0]][sparse[i][1]]=sparse[i][2];
    }
}
```



## 2.队列

### 2.1队列介绍

- 队列是一个有序列表，可以用数组或是链表来实现
- 遵循先入先出的原则。

### 2.2数组模拟队列

![image text](https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/3.png)

![image text](https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/4.png)

### 2.3数组模拟队列代码实现

```c++
//使用数组模拟队列-编写一个ArrayQueue类
class ArrayQueue
{
private:
    int maxSize;//数组的最大容量
    int front;//队列头
    int rear;//队列尾
    int arr[];//该数组用于存放数据，模拟队列

public:
    //创捷队列构造器
    ArrayQueue(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr[maxSize] = {};
        front = -1;//指向队列头部。当还未插入数据时，分析出front是指向队列头的前一个位置，不包含数据。
        rear = -1;//指向队列尾，包含数据。
    }

    //判断队列是否满
    bool isFull() {
        return rear == maxSize - 1;
    }

    //判断队列是否为空
    bool isEmpty() {
        return front == rear;
    }

    //添加数据到队列
    void addQueue(int n) {
        //判断队列是否满
        if (isFull()) {
            cout << "队列满，不能加入数据。" << endl;
            return;
        }
        rear++;//让rear后移
        arr[rear] = n;
    }

    //获取队列的数据，出队列
    int getQueue() {
        //判断队列是否空
        if (isEmpty()) {
            //通过抛出异常
            throw  runtime_error("队列空，不能取数据。");
        }
        front++;//front后移
        return arr[front];
    }

    //显示队列所有数据
    void showQueue() {
        if (isEmpty()) {
            cout << "队列为空，没有数据。" << endl;
            return;
        }
        for (int i = 0; i < maxSize; i++) {
            cout << arr[i] << endl;
        }
    }

    //显示队列的头数据，注意不是取出数据
    int headQueue() {
        if (isEmpty()) {
            throw runtime_error("队列为空，没有数据。");
        }
        return arr[front + 1];
    }
};

int main() {
    //测试
    ArrayQueue aq(3);
    char key = ' ';//接收用户输入
    bool loop = true;
    cout << "输入s（show）：显示队列" << endl;
    cout << "输入e（exit）：退出程序" << endl;
    cout << "输入a（add）：添加数据到队列" << endl;
    cout << "输入g（get）：从队列取出数据" << endl;
    cout << "输入h（head）：查看队列头的数据" << endl;
    while (loop) {
        cin >> key;
        int value = 0;
        switch (key) {
        case 's':
            aq.showQueue();
            break;
        case 'a':
            cout << "输入一个数" << endl;
            cin >> value;
            aq.addQueue(value);
            break;
        case'g':
            try {
                int res = aq.getQueue();
                cout << "取出的数据是" << res << endl;
            }
            catch (exception e) {
                cout << e.what() << endl;
            }
            break;
        case'h':
            try {
                int res = aq.headQueue();
                cout << "队列头的数据是" << res << endl;
            }
            catch (exception e) {
                cout << e.what() << endl;
            }
            break;
        case'e':
            loop = false;
            break;
        default:
            break;
        }
    }
    cout << "程序退出。" << endl;
    system("pause");
    return 0;
}
缺点：虽然取出数据，但却无法再添加数据，数组用了一次之后就不能用了。
```

### 2.4数组模拟环形队列

```c++
思路：
    1.front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。
      front的初始值=0。
    2.rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个位置作为约定。
      rear的初始值=0。
    3.队列满时，条件是：(rear+1)%maxSize==front。
    4.队列空时，条件是：rear==front。
    5.当我们这样分析，队列中有效的数据的个数（rear+maxSize-front）%maxSize。
    6.我们就可以在原来的队列上修改得到环形队列
    
    class CircleArray {
private:
    int maxSize;//数组的最大容量
    int front;//指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素
    int rear;//rear指向队列的最后一个元素的后一个位置，因为希望空出一个位置作为约定
    int arr[];//该数组用于存放数据，模拟队列
public:
    CircleArray(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr[maxSize] = {};
        front = 0;
        rear = 0;
    }
    //判断队列是否满
    bool isFull() {
        return (rear + 1) % maxSize == front;
    }

    //判断队列是否为空
    bool isEmpty() {
        return front == rear;
    }

    //添加数据到队列
    void addQueue(int n) {
        //判断队列是否满
        if (isFull()) {
            cout << "队列满，不能加入数据。" << endl;
            return;
        }
        //直接将数据加入
        arr[rear] = n;
        //将rear后移，这里必须考虑取模
        rear = (rear + 1) % maxSize;
    }

    //获取队列的数据，出队列
    int getQueue() {
        //判断队列是否空
        if (isEmpty()) {
            //通过抛出异常
            throw  runtime_error("队列空，不能取数据。");
        }
        //这里需要分析出front是指向队列的第一个元素
        //1.先把front对应的值保留到一个临时变量
        //2.将front后移
        //3.将临时保存的变量返回
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    //显示队列所有数据
    void showQueue() {
        if (isEmpty()) {
            cout << "队列为空，没有数据。" << endl;
            return;
        }
        //思路：从front开始遍历，遍历多少个元素
        for (int i = front; i < front + size(); i++) {
            cout << arr[i % maxSize] << endl;//i有可能超过了maxSize,所以要取模
        }
    }

    //求出当前队列的有效数据
    int size() {
        return (rear + maxSize - front) % maxSize;//取模的原因：因为是环形队列，rear有可能在front的前面，即rear可能比front小
    }

    //显示队列的头数据，注意不是取出数据
    int headQueue() {
        if (isEmpty()) {
            throw runtime_error("队列为空，没有数据。");
        }
        return arr[front];
    }
};

int main() {
    //测试
    CircleArray aq(4);//其队列的有效数据最大是3
    char key = ' ';//接收用户输入
    bool loop = true;
    cout << "输入s（show）：显示队列" << endl;
    cout << "输入e（exit）：退出程序" << endl;
    cout << "输入a（add）：添加数据到队列" << endl;
    cout << "输入g（get）：从队列取出数据" << endl;
    cout << "输入h（head）：查看队列头的数据" << endl;
    while (loop) {
        cin >> key;
        int value = 0;
        switch (key) {
        case 's':
            aq.showQueue();
            break;
        case 'a':
            cout << "输入一个数" << endl;
            cin >> value;
            aq.addQueue(value);
            break;
        case'g':
            try {
                int res = aq.getQueue();
                cout << "取出的数据是" << res << endl;
            }
            catch (exception e) {
                cout << e.what() << endl;
            }
            break;
        case'h':
            try {
                int res = aq.headQueue();
                cout << "队列头的数据是" << res << endl;
            }
            catch (exception e) {
                cout << e.what() << endl;
            }
            break;
        case'e':
            cout << "程序退出。" << endl;
            loop = false;
            break;
        default:
            break;
        }
    }
    system("pause");
    return 0;
}
```



## 3.链表

### 3.1链表介绍

链表是有序的列表，但是它在内存中存储如下

![image text](https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/5.png)

![image text](https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/6.png)

![image text](https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/7.png)

### 3.2链表实现（增删改查）

```c++
#include<iostream>
using namespace std;

//定义HeroNode，每个Hernode对象就是一个节点
class HeroNode {
public:
	int no;
	string name;
	string nickname;
	HeroNode* next;//指向下一个节点
	//构造器
	HeroNode(int no, string name, string nickname) {
		this->no = no;
		this->name = name;
		this->nickname = nickname;
	}

	//为了显示方便，我们重写toString
	void toString() {
		cout << "HeroNode [no=" << no << "，name = " << name << "，nickname = " << nickname << "]" << endl;
	}
};

//定义SingleLinkedList管理我们的英雄
class SingleLinkedList {
	//先初始化一个头节点，头节点不要动，不存放具体的数据
private:
	HeroNode* head = new HeroNode(0, "", "");
	
public:
	//添加节点到单向链表
	//第一种方法（直接添加到链表尾部，当不考虑编号顺序时
	//1.找到当前链表的最后节点
	//2.将最后这个节点的next指向新的节点
	void add(HeroNode* heroNode) {
		//因为head节点不能动，因此我们需要一个辅助指针遍历temp
		HeroNode* temp = head;
		//遍历链表，找到最后
		while (true) {
			//找到链表的最后一个节点
			if (temp->next == NULL) {
				break;
			}
			//如果没有找到最后
			temp = temp->next;
		}
		//当退出while循环时，temp就指向了链表的最后一个节点
		temp->next = heroNode;
	}

	//第二种方法（按照编号的顺序添加）
	//	1.首先找到新添加的节点的位置，是通过辅助变量（指针），通过遍历来搞定
	//	2.新的节点->next = temp->next
	//	3.将temp->next = 新的节点
	void addByOrder(HeroNode* heroNode) {
		//因为头节点不能动，因此我们仍然通过一个辅助指针来帮助找到添加的位置
		//因为单链表，我们找的temp是位于添加位置的前一个节点，否则插入不了
		HeroNode* temp = head;
		bool flag = false;//标志添加的编号是否存在，默认为false
		while (true) {
			if (temp->next == NULL) {//说明temp已经在链表的最后
				break;
			}
			if (temp->next->no > heroNode->no) {//位置找到，就在temp的后面插入
				break;
			}
			else if (temp->next->no == heroNode->no) {//说明希望添加的heroNode的编号已然存在
				flag = true;//说明编号存在
				break;
			}
			temp = temp->next;//后移，遍历当前链表
		}
		//判断flag的值
		if (flag) {//不能添加，说明编号存在
			cout << "准备插入的英雄的编号" << heroNode->no << "已经存在了，不能加入" << endl;
		}
		else {
			//插入到链表中，temp的后面
			heroNode->next = temp->next;
			temp->next = heroNode;
		}
	}

	//修改节点的信息，根据no编号来修改，即no编号不能改
	//1.根据 newHeroNode的no来修改即可
	void update(HeroNode* newHeroNode) {
		//判断是否为空
		if (head->next == NULL) {
			cout << "链表为空" << endl;
			return;
		}
		//找到需要修改的节点，根据no编号
		//定义一个辅助指针
		HeroNode* temp = head->next;
		bool flag = false;//表示是否找到该节点
		while (true) {
			if (temp == NULL) {
				break;//已经遍历完链表
			}
			if (temp->no == newHeroNode->no) {
				//找到
				flag = true;
				break;
			}
			temp = temp->next;
		}
		//根据flag判断是否找到要修改的节点
		if (flag) {
			temp->name = newHeroNode->name;
			temp->nickname = newHeroNode->nickname;
		}
		else {//没有找到
			cout << "没有找到编号" << newHeroNode->no << "的节点，不能修改。" << endl;
		}
	}

	//从单链表中删除一个节点的思路
	//1.我们先找到需要删除的节点的前一个节点temp
	//2.temp->next=temp->next->next
	//3.被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收
	//删除节点
	void del(int no) {
		HeroNode* temp = head;
		bool flag = false;//标志是否找到待删除的节点
		while (true) {
			if (temp->next == NULL) {
				break;
			}
			if (temp->next->no == no) {
				//找到待删除节点的前一个节点
				flag = true;
				break;
			}
			temp = temp->next;
		}
		//判断flag
		if (flag) {//找到
			temp->next = temp->next->next;
		}
		else {
			cout << "要删除的" <<no << "的节点不存在" << endl;
		}
	}

	//显示链表[遍历]
	void list() {
		//判断链表是否为空
		if (head->next == NULL) {
			cout << "链表为空" << endl;
			return;
		}
		//因为头节点不能动，因此我们需要一个辅助指针来遍历
		HeroNode* temp = head->next;
		while (true) {
			//输出节点信息
			temp->toString();
			//判断是否到链表最后一个结点
			if (temp->next == NULL) {
				break;
			}
			//将temp后移，一定小心
			temp = temp->next;
		}
	}
};

int main() {
	//进行测试
	//先创建节点
	HeroNode hero1(1, "宋江", "及时雨");
	HeroNode hero2(2, "卢俊义", "玉麒麟");
	HeroNode hero3(3, "吴用", "智多星");
	HeroNode hero4(4, "林冲", "豹子头");

	//创建链表
	SingleLinkedList singleLinkedList;

	//按照编号的顺序加入
	singleLinkedList.addByOrder(&hero1);
	singleLinkedList.addByOrder(&hero4);
	singleLinkedList.addByOrder(&hero2);
	singleLinkedList.addByOrder(&hero3);
	singleLinkedList.addByOrder(&hero3);

	singleLinkedList.list();

	//测试修改节点的代码
	HeroNode newHeroNode(2, "小卢", "玉麒麟~~");
	singleLinkedList.update(&newHeroNode);
	cout << "修改后的链表情况" << endl;

	//显示
	singleLinkedList.list();

	singleLinkedList.del(1);
	singleLinkedList.del(4);
	singleLinkedList.del(2);
	singleLinkedList.del(3);
	cout << "删除后的链表情况" << endl;
	singleLinkedList.list();
}
```

