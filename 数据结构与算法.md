# 数据结构与算法

## 1.稀疏数组

因为数组默认值为0，因此记录了很多没意义的数据。

### 1.1基本介绍

当一个数组中大部分元素为0，或者为同一个数值的数组时，可以使用稀疏数组来保存该数据。

### 1.2稀疏数组的处理方法

- 记录数组一共有几行几列，有多少个不同的值。
- 把具有不同值的元素的行列及值记录在一个小规模的数组中（稀疏数组），从而缩小程序的规模。

![image-text]https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/1.png

### 1.3应用实例

![image-text]https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/2.png)

```c++
二维数组转稀疏数组的思路：
    1.遍历原始的二维数组，得到有效数据的个数sum。
    2.根据sum就可以创建稀疏数组 int sparseArr[sum+1][3]。
    3.将二维数组的有效数据存入到稀疏数组。

稀疏数组转二维数组的思路：
    1.先读取稀疏数组第一行，根据第一行数据，创建二维数组，
      int chessArr[sparseArr[0][0]][sparseArr[0][1]]。
    2.再读取稀疏数组后几行的数据，并赋给二维数组即可。
```

### 1.4代码实现

```c++
int main()
{
    //创建一个原始的二维数组11*11
    //0：没有棋子，1：黑子，2：蓝子
    int chessArr1[11 ][11]={};
    chessArr1[1][2]=1;
    chessArr2[2][4]=2;
    
    //将二维数组中转换为稀疏数组
    //1.先遍历二维数组，得出非0数据的个数
    int sum=0;
    for(int i=0;i<11;i++)
    {
        for(int j=0;j<11;j++)
        {
            if(chessArr1[i][j]!=0)
            {
                sum++;
            }
        }
    }
    //2.创建对应稀疏数组
    int sparseArr[sum+1][3]={};
    //2.1给稀疏数组赋值
    sparseArr[0][0]=11;
    sparseArr[0][1]=11;
    sparseArr[0][2]=sum;
    //2.2遍历二维数组，将非0的值存到稀疏数组
    int count=0;//count用来记录是第几个非0值
      for(int i=0;i<11;i++)
    {
        for(int j=0;j<11;j++)
        {
            if(chessArr1[i][j]!=0)
            {
                count++;
                sparse[count][0]=i;
                sparse[count][1]=j;
                sparse[count][2]=chessArr1[i][j];
            }
        }
    }
    
    //将稀疏数组恢复二维数组
    //1.先读取稀疏数组第一行，根据第一行数据，创建二维数组
    int chessArr2[sparseArr[0][0]][sparseArr[0][1]]={};
    // 2.再读取稀疏数组后几行的数据，并赋给二维数组即可
    for(int i=1;i<sum+1;i++)
    {
        chessArr2[sparseArr[i][0]][sparse[i][1]]=sparse[i][2];
    }
}
```



## 2.队列

### 2.1队列介绍

- 队列是一个有序列表，可以用数组或是链表来实现
- 遵循先入先出的原则。

### 2.2数组模拟队列

![image-text]https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/3.png)

![image-text]https://github.com/Jomocool/Data_Structure_Algorithm/blob/main/DSA-img/4.png)

### 2.3数组模拟队列代码实现

```c++
//使用数组模拟队列-编写一个ArrayQueue类
class ArrayQueue
{
private:
    int maxSize;//数组的最大容量
    int front;//队列头
    int rear;//队列尾
    int arr[];//该数组用于存放数据，模拟队列

public:
    //创捷队列构造器
    ArrayQueue(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr[maxSize] = {};
        front = -1;//指向队列头部。当还未插入数据时，分析出front是指向队列头的前一个位置，不包含数据。
        rear = -1;//指向队列尾，包含数据。
    }

    //判断队列是否满
    bool isFull() {
        return rear == maxSize - 1;
    }

    //判断队列是否为空
    bool isEmpty() {
        return front == rear;
    }

    //添加数据到队列
    void addQueue(int n) {
        //判断队列是否满
        if (isFull()) {
            cout << "队列满，不能加入数据。" << endl;
            return;
        }
        rear++;//让rear后移
        arr[rear] = n;
    }

    //获取队列的数据，出队列
    int getQueue() {
        //判断队列是否空
        if (isEmpty()) {
            //通过抛出异常
            throw  runtime_error("队列空，不能取数据。");
        }
        front++;//front后移
        return arr[front];
    }

    //显示队列所有数据
    void showQueue() {
        if (isEmpty()) {
            cout << "队列为空，没有数据。" << endl;
            return;
        }
        for (int i = 0; i < maxSize; i++) {
            cout << arr[i] << endl;
        }
    }

    //显示队列的头数据，注意不是取出数据
    int headQueue() {
        if (isEmpty()) {
            throw runtime_error("队列为空，没有数据。");
        }
        return arr[front + 1];
    }
};

int main() {
    //测试
    ArrayQueue aq(3);
    char key = ' ';//接收用户输入
    bool loop = true;
    cout << "输入s（show）：显示队列" << endl;
    cout << "输入e（exit）：退出程序" << endl;
    cout << "输入a（add）：添加数据到队列" << endl;
    cout << "输入g（get）：从队列取出数据" << endl;
    cout << "输入h（head）：查看队列头的数据" << endl;
    while (loop) {
        cin >> key;
        int value = 0;
        switch (key) {
        case 's':
            aq.showQueue();
            break;
        case 'a':
            cout << "输入一个数" << endl;
            cin >> value;
            aq.addQueue(value);
            break;
        case'g':
            try {
                int res = aq.getQueue();
                cout << "取出的数据是" << res << endl;
            }
            catch (exception e) {
                cout << e.what() << endl;
            }
            break;
        case'h':
            try {
                int res = aq.headQueue();
                cout << "队列头的数据是" << res << endl;
            }
            catch (exception e) {
                cout << e.what() << endl;
            }
            break;
        case'e':
            loop = false;
            break;
        default:
            break;
        }
    }
    cout << "程序退出。" << endl;
    system("pause");
    return 0;
}
缺点：虽然取出数据，但却无法再添加数据，数组用了一次之后就不能用了。
```

### 2.4数组模拟环形队列

```c++
思路：
    1.front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。
      front的初始值=0。
    2.rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个位置作为约定。
      rear的初始值=0。
    3.队列满时，条件是：(rear+1)%maxSize==front。
    4.队列空时，条件是：rear==front。
    5.当我们这样分析，队列中有效的数据的个数（rear+maxSize-front）%maxSize。
    6.我们就可以在原来的队列上修改得到环形队列
    
```

